outputmacro: ^dbFirst($_arg1)
	    $_arg1.
	    ^flushoutput()

topic: ~kaufabsicht1 keep (~kaufen)



u: INTRO ([ ~kaufen  buy ]) Du möchtest also etwas kaufen, sehe ich das richtig?

	#! Ich suche / will kaufen / shop
	a: ( _~yes ) $introyes = _0 if (^dbinit(dbname = Uni-Shop port = 5432 user = postgres password = )) {In diesem Fall kann ich dir dabei helfen, was aus dem Uni-Shop zu suchen, $kunde. ^reuse( FIRSTQ )}
                  else {dbinit failed - $$db_error}

	# introyes nur um zu bestätigen, dass auch "JA" gesagt wurde!

	#! Nein.
	a: ( ~no ) Tut mir Leid, ich kann eigentlich nur beraten. Sicher, dass du nicht doch etwas aus dem Uni-Shop suchst?
	    #! Ja.
	    b: ( ~yes ) Schön zu hören. ^reuse( INTRO )
	    #! Nein.
	    b: ( ~no ) Das ist schade.
		# Hiernach muss sollte man einen Schluss implementieren.


u: FIRSTQ ([$introyes aussuchen]) Wir können nach einem Geschenk suchen oder einen Artikel für einen bestimmten Zweck. Was möchtest du?

    #! Geschenk.
    a: ( ~geschenkidee ) $anwendungszweck = null Du suchst nach einem Geschenk. Ich kann dir folgende Kategorien anbieten: if (^dbexecute(^"SELECT DISTINCT geschenkidee FROM geschenk;" '^dbFirst )) {}
       else {dbexecute failed list from table- $$db_error ^reuse( FIRSTQ ) }

        #! Mitbringsel
        b: ( _~geschenkidee ) $geschenkidee = _0 ^gambit( ~keyexgeschenk )



	 #! besonderer Zweck
	 a: ( ~anwendung ) $geschenkidee=null Du hast also einen bestimmten Zweck im Sinn. Ich kann dir folgende Kategorien anbieten: if (^dbexecute(^"SELECT DISTINCT anwendungsgebiet FROM anwendung;" '^dbFirst )) { ^gambit( ~keyexanwendung ) }
                                else {dbexecute failed list from table- $$db_error ^reuse( FIRSTQ ) }

        #! EssenTrinken
        b: ( _~anwendungszweck ) $anwendungszweck = _0 ^gambit( ~keyexanwendung )


# Ausführung nur wenn Geschenk nicht null!
topic: ~keyexgeschenk keep (~geschenkidee)

t: (~geschenkidee) Debug: Reminder, für Geschenk ein $geschenkidee. Anwendungszweck war $anwendungszweck ^reuse ( ASKNAME )

u: ASKNAME () Ich will dir bei der Produktsuche helfen. Weißt du, wie der Artikel heißt, den du du suchst?
	a:  ( _~things ) $things = _0 Alles klar, ein $things. ^reuse ( AUSF )
	a: ( ~no ) $things = null Kein Thema, dafür bin ja da. ^reuse ( ART )
	a: () $things = null Ich konnte leider nichts mit deiner Eingabe anfangen. Egal, versuchen wir's mal weiter! # Was kommt hierhin? ART oder ASKNAME?

u: ART (!$things) Weißt du zumindest, was für eine Art Artikel du willst? # Wenn für $things nix da ist, dann ART.
	a: (_~art) $art = _0 Also ein $art. Gut, machen wir weiter! ^reuse ( AUSF )
	a: () Okay. Versuchen wir es weiter!

u: AUSF () Kannst du was zum Produkt selbst sagen? Welche Sprache oder Farbe soll es haben?
	a: (_~ausfuehrung) $ausfuehrung = _0 Alles klar, es ist $ausfuehrung. ^reuse ( PRICE )
	a: () Okay.

u: PRICE () Wie viel soll es denn maximal kosten?
	a: (_~positiveinteger) $preis = _0 Es soll maximal $preis kosten. ^gambit( ~dbsearch )
	a: () Wir konnten keinen Preis feststellen.

# gosearch muss einen Wert haben, damit die Datenbanksuche erfolgt.
# gosearch soll also verhindern, dass ohne NLI eine Datenbanksuche erfolgt
# Variablen sind: $things $art $ausfuehrung $preis für Tabelle Artikel
# $geschenkidee für Geschnk
# $anwendungszweck für Anwendung


topic: ~dbsearch [] ($gosearch)

# IDEE für jetzt: Benutzen einer View
# IDEE für Später: Um richtig nutzen von der Spalte queried zu machen, EINE VIEW PRO USER.

	# In Relation Artikel 'queried' auf 1 setzen
t: ( db ) Debug:Willkommen bei der Datenbanksuche if (^dbexecute(^"UPDATE artikel SET queried=1 WHERE artnr LIKE '0%';
                                                                    UPDATE artikel set queried=1 WHERE name=(SELECT name FROM Artikel NATURAL JOIN geschenk WHERE geschenkidee ='Mitbringsel' ORDER BY artnr LIMIT 1);"))
		{Ich kann dir Folgendes anbieten: if (^dbexecute (^"SELECT name FROM artikel NATURAL JOIN geschenk WHERE queried=1 ORDER BY artnr LIMIT 1;" '^dbFirst )) {Möchtest du mehr Information? Wenn es dir nicht gefällt, kann ich weiter suchen.}
	             else {dbexecute failed - $$db_error}
	    } else {dbexecute failed - $$db_error}

    #! Mehr Information.
    a: ( {mehr} [Infos Information] ) ^reuse (INFORMATION)

    #! Weiter suchen
    a: ( [weitersuche "weiter suchen" suchen "such weiter"] ) ^reuse ( SEARCHAGAIN )



t: INFORMATION ( {mehr} [Infos Information] )  [Die Beschreibung lautet:] [Also, hier steht:]
        if (^dbexecute(^"SELECT beschreibung FROM artikel WHERE queried=1 LIMIT 1;" '^dbFirst )) {Gefällt es dir? Wenn du nein sagst, suche ich weiter.}
         else {dbexecute failed - $$db_error}

   #! Nein.
   a: ( ~no ) ^reuse ( SEARCHAGAIN )


t: SEARCHAGAIN () [Vielleicht gefällt dir dieses besser:] [Das habe ich noch gefunden:] [Was ist hiermit?]
        if (^dbexecute(^"UPDATE artikel SET queried=2 WHERE queried=1;
                         UPDATE artikel set queried=1 WHERE name=(SELECT name FROM Artikel NATURAL JOIN geschenk WHERE geschenkidee='$geschenk' ORDER BY artnr LIMIT 1); )) {
             if(^dbexecute(^" SELECT name FROM artikel NATURAL JOIN geschenk WHERE queried=1 ORDER BY artnr LIMIT 1;" '^dbFirst )) {Soll ich dir die Beschreibung anzeigen?}
            else {dbexecute failed - $$db_error} }
        else {dbexecute failed - $$db_error}

    #! Ja.
    a: ( [~yes bitte] ) ^reuse ( INFORMATION )




	# Herausfinden: Wie formuliere ich eine Queue, wenn ich praktisch nicht weiß, welche Variablen null sind un welche nicht?
	# Einzige Idee: mehrere t: anlegen je nach dem, welche daten vorhanden sind (Anfangen mit dem Fall, dass alle/die meisten daten da sind)
	# Hier zunächst: Eine Beispielqueue, um zu ermitteln, wie man queues in postgres ausführt

	# Wie kann ich die Ergebnisse ausgeben? Hier: Das resultat aus Beschreibung
	# Die Queue scheint zu funktionieren - über PGSQL gibt es kein Problem.
	# Sobald das vorige geklärt ist: Gefundenes Nehmen und dessen queried-Wert auf true setzen.