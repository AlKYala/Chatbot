outputmacro: ^dbFirst($_arg1)
	    $_arg1.
	    ^flushoutput()

topic: ~kaufabsicht keep (~kaufen)
# Bis jetzt unvollständigkeiten. Das wird noch überarbeitet. 

 u: KEINEABSICHT1 (~no ) ^reuse( NOBUY )
 u: KEINEABSICHT2 ( ~nicht ) ^reuse( NOBUY )

u: INTRO (~kaufen) Du möchtest also etwas kaufen, sehe ich das richtig?

	# Ich suche / will kaufen / shop
	a: ( _~yes ) $introyes = _0 if (^dbinit(dbname = postgres port = 5432 user = postgres password = 1234)) {In diesem Fall kann ich dir dabei helfen, was aus dem postgres zu suchen, $kunde. ^reuse( FIRSTQ )}
                  else {dbinit failed - $$db_error}

	# introyes nur um zu bestätigen, dass auch "JA" gesagt wurde!
	# a: und b: sind quasi gesprächsverläufe - zunächst kommt a: und falls reuse, dann b usw. 

	#! Nein.
	a: NOBUY ( ~no ) Tut mir Leid, ich kann eigentlich nur beraten. Sicher, dass du nicht doch etwas aus dem postgres suchst?
	    b: ( ~yes )  $introyes = _0 if (^dbinit(dbname = postgres port = 5432 user = postgres password = 1234)) {Schön zu hören. ^reuse( FIRSTQ )}
                                      else {dbinit failed - $$db_error ^reuse(FIRSTQ)}
	    b: ( ~no ) $enterEnd2 = 1 Das ist schade. ^gambit( ~ende )
		b: ( ~nicht ) $enterEnd2 = 1 Das ist schade. ^gambit( ~ende )

	a: () Könntest du das bitte wiederholen?

	     # Ich suche / will kaufen / shop
           	b: ( _~yes ) $introyes = _0 if (^dbinit(dbname = postgres port = 5432 user = postgres password = 1234)) {In diesem Fall kann ich dir dabei helfen, was aus dem postgres zu suchen, $kunde. ^reuse( FIRSTQ )}
                else {dbinit failed - $$db_error ^reuse(FIRSTQ)}

         # Antwort immer noch unverständlich
            b: () Glaubst du es gibt eine schriftliche Variante des Murmelns? Irgendwie verstehe ich dich nicht so recht.
                  $introyes = _0 if (^dbinit(dbname = postgres port = 5432 user = postgres password = 1234)) {Egal, fangen wir mal an. ^reuse( FIRSTQ )}
                  else {dbinit failed - $$db_error ^reuse(FIRSTQ)}

         #! Nein.
         	b: NOBUY ( ~no ) Tut mir Leid, ich kann eigentlich nur beraten. Sicher, dass du nicht doch etwas aus dem postgres suchst?
         	    c: ( ~yes ) $introyes = _0 if (^dbinit(dbname = postgres port = 5432 user = postgres password = 1234)) {Schön zu hören. ^reuse( FIRSTQ )}
                             else {dbinit failed - $$db_error ^reuse(FIRSTQ)}
         	    c: ( [ ~no ~nicht ] ) $enterEnd2 = 1 Das ist schade. ^gambit( ~ende )


u: FIRSTQ ($introyes) Wir können nach einem Geschenk suchen oder einen Artikel für einen bestimmten Zweck. Was möchtest du?
      $anwendungszweck = ^"'nichts'"
      $geschenkidee = ^"'nichts'"


	# In den nächsten zwei Antworten wird quasi gesagt, dass man was mit Geschenk oder Anwendungszweck haben will.
	# Aber nicht mehr, sodass erneut gefragt wird (mit reuse)
    a: (~willGeschenk) $anwendungszweck = ^"'nichts'" Du suchst nach einem Geschenk. Ich kann dir folgende Kategorien anbieten: if (^dbexecute(^"SELECT DISTINCT geschenkidee FROM geschenk;" '^dbFirst )) {}
       else {dbexecute failed list from table- $$db_error ^reuse( FIRSTQ ) }
	   
	# Irgendwas mit Zweck 
	a: (~willZweck) $geschenkidee = ^"'nichts'" Du suchst für etwas zu einem Zweck. Ich kann dir folgende Kategorien anbieten: if (^dbexecute(^"SELECT DISTINCT anwendungsgebiet FROM anwendung;" '^dbFirst )) {}
       else {dbexecute failed list from table- $$db_error ^reuse( FIRSTQ ) }


    # Konkrete Angabe - gehe direkt weiter!
    a: ( _~geschenkidee ) $anwendungszweck = ^"'nichts'" $geschenkidee = ^"''_0'" ^gambit( ~keyexgeschenk )

	# Konkrete Angabe
	a: ( _~anwendungszweck ) $anwendungszweck = ^"''_0'" $geschenkidee = ^"'nichts'" ^gambit( ~keyexanwendung )
	
	# Nicht erkannt
	a: () Könntest du das bitte wiederholen? ^reuse( FIRSTQ )
	b: () Könntest du das bitte wiederholen? ^reuse( FIRSTQ )

# Hiernach muss keyexanwendung oder keyexgeschenk finden. 
# Diese sind nun Ausgelagert, backup vorhanden.
# https://www.chatbots.org/ai_zone/viewthread/3659/
# https://www.chatbots.org/ai_zone/viewthread/3665/
# Überprüfen ob Variable vorhanden ist immer mit ( $varname )