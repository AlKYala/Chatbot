\chapter{ChatScript: Grundlagen}
\label{sec:ChatScript: Grundlagen}

ChatScript ist ein Framework, das es Entwicklern erlaubt, regelbasierte Chatbots zu entwickeln. Es handelt sich hierbei um  ein "Natural Language Tool" mit eigenem Interpreter, welcher Code in C++ übersezt. 


\section{Regeln}
\label{sec:ChatScript: Regeln}

Regeln sind ein elementarer Bestandteil in ChatScript. In diesen Regeln werden unter Anderem Nutzereingaben analysiert, Antworten des Bots festgelegt, Datenbankabfragen ausgeführt und der Gesprächsablauf gesteuert.\\
In Augusta finden sich Regeln in verschiedenen Formen wieder. Diese sind: 

\begin{itemize}
\item {\lstinline|t:|  für Ausgaben des Chatbots, ohne folgende Antwort}
\item {\lstinline|u:|  für Ausgaben in Form von Fragen, das beduetet, dass auf Regeln mit u: eine Antwort des Nutzers folgen muss} 
\item {\lstinline|a:|, \lstinline|b:| bis \lstinline|q:|  für Antworten des Nutzers. Auf diese Regeln können Pattern-Matching-Ansätze angewandt werden, um Teile der Eingabe ggf. zu extrahieren. Sie finden sich in den Regeln \lstinline|t:| und \lstinline|u:|.}
\end{itemize}

Regeln haben, wenn auch  optional, meist einen Bezeichner, eine Bedingung zur Ausführung und es lassen sich dabei Variablen zuweisen. Ein abstraktes Beispiel:

\begin{lstlisting}{}					%[caption=Syntax für Regeln}]
t: BEZEICHNER (KONDITION) $meineVariable=Wert		Ausgabe des Bots
\end{lstlisting}

Im Folgenden einige Beispiele für Regeln:

\begin{lstlisting}{}					%[caption={Beispiel für t:}]
t:  ( %input<%userfirstline )
    ^keep()
    [Hallo] [Hi] [Guten Tag], ich bin Augusta und kann dich beraten, wenn du etwas aus dem Online-Shop suchst. ^reuse( GREET )
\end{lstlisting}

In dieser Regel wird der Nutzer begrüßt und dann zur Regel GREET weitergeleitet.
Der Dialog kann genauer mit den Antwortmöglichkeiten über \lstinline|a:|, \lstinline|b:| und so weiter wiedergegeben werden. Ein Beispiel dafür:

\begin{lstlisting}{}				%[caption={Beispiel für Gesprächsablauf mit Antworten u:, a: und b:}]
 u: INTRO ($enter211) [Das ist gut] [Das ist toll] [Das freut mich], [dabei kann ich dir helfen] [ich kann dir dabei helfen, etwas zu finden] [ich kann dich beraten]. Also dann, wollen wir loslegen?

	a: ( ~positiv ) $introyes = 1a
	# DATENBANK
	    if (^dbinit(dbname = Uni-Shop port = 5432 user = postgres password = 1234))
	        {[Lass uns anfangen] [Super, auf geht's]!  ^reuse( FIRSTQ )
	    } else {dbinit failed - $$db_error  ^reuse( FIRSTQ ) }
			
	a: ( ~negativ ) Tut mir Leid, ich kann eigentlich nur beraten. Bist du dir sicher, dass du nichts aus dem Shop möchtest?
	# DATENBANK
		b: ( ~negativ )  $introyes = 1a if (^dbinit(dbname = Uni-Shop port = 5432 user = postgres password = 1234 )) {Schön zu hören. ^reuse( FIRSTQ )}
                                      else {dbinit failed - $$db_error ^reuse(FIRSTQ)}
	  b: ( ~positiv ) $enterEnd2 = 1b Das ist schade. ^reuse( ~ende.ASKIFHAPPY )
\end{lstlisting}

In diesem Abschnitt fragt der Bot mit zufällig ausgewählter Frage, ob der Kunde etwas kaufen möchte. Falls die Eingabe des Kunden ein Wort aus dem Konzept ~positiv enthält, wird entsprechend die Datenbank geladen und die Regel FIRSTQ im selben Topic aktiviert. Ist die Eingabe allerdings einem Wort aus dem Konzept ~negativ zuzuordnen, so wird gefragt, ob der Kunde sich sicher ist. Je nach Antwort darauf wird eine entsprechende Regel, das heißt, eine der beiden \lstinline|b:|-Regeln ausgeführt.\\ 


\section{Topics}
\label{sec:ChatScript: Topics}

Die Quelldateien in einem ChatScript-Programm werden auch als "`Topics"' bezeichnet und haben die Dateiendung .top. Topics können als Zusammenfassung mehrerer Regeln betrachtet werden. Daher bietet es sich an, Topics als Module eines Chatbots zu handhaben. So wird zum Beispiel in diesem Projekt der Datenbankabfrage ein eignenes Topic zugewiesen.\\
Topics beginnen immer mit einer Tilde ("`~"') als Präfix gefolgt vom Topicnamen, meist als erste Zeile in einer .top-Datei oder vor dem Auflisten der Regeln:

\begin{lstlisting}{}				%[caption={Topicbezeichner in dbsearch.top}]
topic: ~dbsearch  [] ($gosearch)
\end{lstlisting}

Gegebenenfalls findet sich vor dem Topicnamen noch die Definition eines Outputmacros, das in dem Topic verwendet wird. Für weitere Informationen über Outputmacros siehe Unterkapitel \ref{sec:dbexecute}.\\


\section{Konzepte}
\label{sec:ChatScript: Konzepte}

Syntaktisch werden Konzepte wie Topics gehandhabt, das heißt, dass Konzepte mit \lstinline|~konzeptname| referenziert werden. Ein Konzept kann abhängig Einträgen als eine Menge von Synonymen, Hyponymen oder beidem verstanden werden, ähnlich zu den Einträgen in einem Thesaurus. Obwohl es sich hier um Mengen handelt, stehen diese aus syntaktischer Sicht in eckigen Klammern ("`[]"'). Ein Beispiel anhand des Konzepts \texttildelow ciao, das Synonyme beschreibt:

\begin{lstlisting}{}					%[caption={Konzept 'ciao' aus konzepte.top}]
concept: ~ciao [ciao tschüss "good bye" bye "daje" "eddi un merci" "äddi a merci"]
\end{lstlisting}

Anzumerken ist, dass Ausdrücke aus mehreren Wörtern, sogenannte "`multiword expressions"', in Anführungszeichen stehen müssen, da die einzelnen Bestandteile dieser sonst als eigenständige Elemente betrachtet werden.\\

In "`Augusta"' sind Konzepte besonders wichtig, da es sich anbietet, das Pattern-Matching von Konzepten abhängig zu machen. So wird mit Hilfe von Konzepten das Arbeiten mit der PostgreSQL-Schnittstelle gewährleistet: Für jeden möglichen Eintrag pro Spalte in der PostgreSQL-Datenbank existiert ein Konzept. Als Beispiel alle Einträge für die Spalte "`Anwendungszweck"' (zur Datenbank s. \ref{sec:DB}), hier handelt es sich also eher um Hyponyme:  

\begin{lstlisting}{}						%[caption={Konzept 'anwendungszweck' aus konzepte.top}]
concept: ~anwendungszweck [Unterhaltung Schreibwaren EssenTrinken Essentrinken Alltag Accessoire]
\end{lstlisting}

Der Nutzer beschreibt beispielsweise in einem Satz, welchen Anwendungszweck das gesuchte Produkt erfüllen soll. Wird ein Wort aus dem Konzept gefunden, so wird dieses nach den Vorgaben des Skriptes als solches erkannt. Damit wird sichergestellt, dass in den Queries nur Eigenschaften vorkommen, die in Datenbankeinträgen existieren. Sollte der Anwender nach Eigenschaften suchen, die nicht existieren, so werden diese ignoriert (zum Pattern-Matching s. \ref{sec:ChatScript: Pattern-Matching} und zur Query s. \ref{sec:SQL}). \\

Des Weiteren erlaubt es ChatScript, mehrere verschiedene Konzepte in einem Konzept zu vereinen. Beispielsweise ist das Konzept \texttildelow positivkaufen als Oberkategorie, bestehend aus drei anderen Konzepten, die bedeutungsähnlich sind, zu verstehen:

\begin{lstlisting}{}					%[caption={Konzept 'positivkaufen' aus konzepte.top}]
concept: ~positivkaufen [ ~yes ~zustimmung ~kaufen]
\end{lstlisting}

\texttildelow positivkaufen enthält somit alle Wörter, die in \texttildelow yes, \texttildelow zustimmung und \texttildelow kaufen vorkommen.\\


\section{ChatScript: Variablen}
\label{sec:ChatScript: Variablen}
Variablen in Augusta kommen größtenteils in der Form \lstinline|$variablenname| vor. Das "`\lstinline|$|"' vor dem Identifier bedeutet, dass diese Variable gloabl ist und über die Regel hinaus existiert. Variablen werden für gewöhnlich im Kopf einer Regel instanziiert. Bei den zugewiesenen Werten kann es sich auch etwas handeln, das mit Hilfe von Pattern-Matching gefunden und aus der Antwort des Benutzers extrahiert wurde. Im folgenden Beispiel wird das erste Wort der Nutzereingabe, welches sich im Konzept \texttildelow geschenkidee befindet, in der Variable \lstinline|$geschenkidee| gespeichert. 

\begin{lstlisting}{}					%[caption={Zuweisung des Wertes einer Variable }]
a: ( _~geschenkidee ) $anwendungszweck = ^"'nichts'" $geschenkidee = ^"''_0'"}
\end{lstlisting}

Bereits instanziierte Variablen lassen sich mit dem Befehl \lstinline|^walkvariables|(\^outputmacro) einsehen, sofern ein entsprechendes Outputmacro vorhanden ist.\\
Da das Zurücksetzen von Variablen nicht trivial ist, lassen sich diese mit dem Befehl \lstinline|^reset( VARIABLES )| löschen. Allerdings ist dieser Befehl sehr mächtig, da er fast alle Variablen (außer \$\_-Variablen) zurücksetzt. In der Dokumentation (S. 54 in ChatScript - Sytem-Functions-Manual in \citet{chatscript2019}) wird zwar daraufhingewiesen, dass \$\$-Variablen und Bot-Variablen bestehen bleiben, in unserem Fall hat sich das allerdings nicht bewahrheitet.\\
Wenn man verhindern möchte, dass eine Variable zurückgesetzt wird, empfiehlt es sich diese als temporäre Variable wie folgt zwischenzuspeichern:

\begin{lstlisting}{}					%[caption={Zwischenspeichern einer Variable}]
	$_cs_bottmp = $cs_bot
    ^reset( VARIABLES )
    #....
	$cs_bot = $_cs_bottmp 
\end{lstlisting}

Dieser Schritt findet in dem Topic Ende statt. Dies ist nötig, um zu gewährleisten, dass sowohl Informationen wie der Name des Kunden als auch die Instanz des Bots nicht verloren gehen, wenn eine weitere Empfehlung im selben Gespräch erfolgen soll.\\


\section{Variablen als Bedingungen zur Steuerung des Programmablaufs}
\label{sec:ChatScript: Variablen als Bedingungen zur Steuerung von Programmablauf}

Nativ wählt ChatScript Regeln in einem Topic zufällig aus, um durch themenbezogene zufällige Antworten natürlich zu wirken. Da Augusta, ein Chatbot zur Kaufberatung, jedoch eine lineare Konversation gewährleisten muss, wird in fast allen Regeln mit Bedingungen gearbeitet. Der Regelkopf aus FIRSTQ aus dem Topic Kaufabsicht als Beispiel: 

\begin{lstlisting}{}					%[caption={Regelkopf von FIRSTQ in kaufabsicht.top}]
u: FIRSTQ ($introyes) Wir können nach etwas zum ... 
\end{lstlisting}

Die Regel FIRSTQ darf nur aktiviert werden, sofern die Variable \$introyes existiert. 

Ähnlich lässt es sich auch verhindern, dass der Bot in eine Regel übergeht. Es wird eine Variable, die in keiner Regel instanziiert wird, als Bedingung gestellt, wie in STARTKAUF aus Kaufabsicht: 

\begin{lstlisting}{}					%[caption={Regelkopf von STARTKAUF in kaufabsicht.top}]
t: STARTKAUF ($enter999) ^reuse( INTRO)
\end{lstlisting}

Die Regel STARTKAUF ist gewöhnlich nicht betretbar für den Bot, da \lstinline|$enter999| als Variable nie instanziiert wird. Selbiges gilt für alle Regeln, deren Bedingung die Existenz einer Variable mit \lstinline|$enter...| erfordert. Diese Bedingungen dienen dazu, um ein zufälliges Springen des Bots zu verhindern. Hier muss manuell von einer anderen Regel auf diese weitergeleitet werden, was mit Hilfe von Befehlen zur Steuerung des Programmablaufs erfolgt.\\

Alternativ, jedoch nicht so häufig, ist die Bedingung, dass ein Wort eines Konzepts zu erwähnen ist, damit eine Regel betreten wird. Als Beispiel der Regelkopf einer Regel aus Kaufabsicht:

\begin{lstlisting}{}						%[caption={Regelkopf einer Regel in kaufabsicht.top}]
b: (~willGeschenk) $anwendungszweck = ^"'nichts'" Du möchtest etwas verschenken. Ich kann dir folgende Kategorien anbieten:
\end{lstlisting}

Diese Regel, sofern erreichbar, erfordert von der Nutzereingabe, dass ein Wort aus dem Konzept \texttildelow willGeschenk erwähnt wird. Ist dies nicht der Fall, so wird  diese Regel nicht betreten.\\


\section{Befehle zur Steuerung von Programmablauf}
\label{sec:ChatScript: Befehle zur Steuerung von Programmablauf}

In Augusta wurden zwei Methoden genutzt, um den Gesprächsverlauf zu lenken. Dabei handelt es sich zum einen um \lstinline|^gambit(~topic)| und zum anderen um \lstinline|^reuse(~topic.rule)|. Im Laufe des Projekts hat sich \lstinline|^reuse(~topic.rule)| als praktischer herausgestellt, da das direkte Springen in Regeln desselben Topics als auch in Regeln anderer Topics möglich ist. Des Weiteren ignoriert \lstinline|^reuse| die Bedingungen der Zielregel, sodass Regeln, unabhängig davon, ob ein Wort des geforderten Konzepts oder die geforderte Variable existiert, betreten werden können. Sofern sich eine Regel im selben Topic befindet, muss in \lstinline|^reuse| nur die Zielregel angegeben werden:

\begin{lstlisting}{}					%[caption={Regel STARTKAUF in kaufabsicht.top}]
t: STARTKAUF ($enter999) ^reuse( INTRO)
\end{lstlisting}

Wird die Regel STARTKAUF betreten, so wird in die Regel INTRO desselben Topics übergegangen. 

\begin{lstlisting}{}					%[caption={Regel in keyexonesentence.top}]
a: (~positiv) $gosearch = 1c Alles klar! Ich suche mal im Shop. ^reuse( ~dbsearch.WELCOME )
\end{lstlisting}

Sofern ein Wort aus dem Konzept \texttildelow positiv aus der Nutzereingabe erkannt wird, so wird diese Regel ausgeführt und anschließend die Regel WELCOME in Dbsearch, einem anderen Topic, betreten.\\

Im Verlauf der Entwicklung wurde \lstinline|^gambit| mit \lstinline|^reuse| ersetzt, da \lstinline|^reuse| eine präzisere Steuerung des Programmablaufs erlaubt. Während \lstinline|^gambit| lediglich in eine anderes Topic springt und dieses von der ersten betretbaren Regel an ausführt, lässt sich durch \lstinline|^reuse| festlegen, welche Regel zu betreten ist, ohne auf die Bedingung der Zielregel achten zu müssen.\\


\section{Pattern-Matching}
\label{sec:ChatScript: Pattern-Matching}

ChatScripts Interpreter bietet einen hauseigenen Pattern-Matcher zum Vergleichen von Nutzereingaben. Diese Ansätze eignen sich an erster Stelle dazu, Bedingungen für Regeln zu schreiben. Die einfachste Form, um eine Nutzereingabe abzugleichen, ist, zu überprüfen, ob Nutzereingaben ein aus Konzepten bekanntes Token enthalten. Die folgende Regel überprüft, ob die Nutzereingabe ein Wort aus dem Konzept \texttildelow positiv enthält. Ist dies der Fall und ist die Regel erreichbar, so wird die folgende Regel ausgeführt:

\begin{lstlisting}{}						%[caption={Regel in kaufabsicht.top}]
c: ( ~positiv ) $enterEnd2 = 1b Das ist schade. ^reuse( ~ende.ASKIFHAPPY )
\end{lstlisting}

Es besteht des Weiteren die Möglichkeit, eine Nutzereingabe auf mehrere Konzepte zu überprüfen: 

\begin{lstlisting}{}						%[caption={Regel in kaufabsicht.top}]
b: ( [~no ~nicht] ) $enterEnd2 = 1b In Ordnung. ^reuse( ~ende.ASKIFHAPPY )
\end{lstlisting}

Außerdem stellt ChatScript Mittel bereit, um Aussagen über die Reihenfolge von Wörtern in einer Nutzereingabe zu treffen. In der Regel KEINE\_Vorstellung aus Introductions wird überprüft, ob das Wort "`nicht"' in derselben Nutzeringabe wie ein Wort aus dem Konzept \texttildelow sagen vorkommt. Dabei wird nicht eingeschränkt, an welchem Index die Wörter in der Nutzereingabe vorkommen, sodass Nutzereingaben wie "`Das will ich nicht verraten"' oder "`Nicht das will ich verraten"' von dieser Bedingung akzeptiert werden. 

\begin{lstlisting}{}						%[caption={Regel KEINE\_VORSTELLUNG in introductions.top}]
a: KEINE_VORSTELLUNG (<<[sagen] nicht>>) [Das verstehe ich] [Das kann ich nachvollziehen]. ^reuse(~kaufabsicht.STARTKAUF)
\end{lstlisting}

Es ist auch möglich, Wörter aus Nutzereingaben zu herauszusuchen. Für diesen Zweck bietet ChatScript Wildcards der Form \lstinline|*n|. Diese erlauben es, Token an einer bestimmten Stelle zu extrahieren und gegebenenfalls in einer Variable zu speichern. 

\begin{lstlisting}{}							%[caption={Regel in introductions.top}]
a: VORSTELLUNG ([heiße bin ist lautet] _*1 >)
	    if ($cs_token == $stdtoken)
           {
           $cs_token = #DO_INTERJECTION_SPLITTING |
                       #DO_SUBSTITUTE_SYSTEM | #DO_NUMBER_MERGE |
                       #DO_PARSE
           retry(SENTENCE)
           }
        $kunde =  pos(noun '_0 proper)
\end{lstlisting}

Im Grunde wird hier das erste Wort nach "`heiße"', "`bin"', "`lautet"' oder "`ist"' genommen und in der Variable \lstinline|$kunde| gespeichert. \\

Wildcards spielen in Augusta eine zentrale Rolle, wenn es darum geht, Kundenwünsche zu verarbeiten. In KeyExOnesentence finden sich verschiedene Muster zum Verständnis von Kundenwünschen. Dabei wird darauf geachtet, dass Wörter erwähnt werden, die in den Konzepten vorkommen, sodass eine Query anhand der gegebenen Wörtern möglich ist: 

\begin{lstlisting}{}				%[caption={Muster 1 in keyexonesentence.top}]
    a: ( !!~positiveinteger * _~thingsandart {in} _~ausfuehrung * {_~positiveinteger} *  )
      # Test, ob _0 Name oder Art ist
      if (pattern _0~things) {$things = ^"''_0'" zusammenfassung = ^join($zusammenfassung ^" Das Produkt heißt $things.")
      } else {$art = ^"''_0'"  $zusammenfassung = ^join($zusammenfassung ^" Dein Produkt fällt unter den Obergriff $art.")}
      $ausfuehrung = ^"''_1'"
      # Optionaler Preis
      if ( _2 AND ^isnumber(_2) ) {$preis = ^"''_2'" $zusammenfassung = ^join($zusammenfassung ^" Es ist in $ausfuehrung und maximal soll es $preis Euro kosten.")
      } else {$zusammenfassung = ^join($zusammenfassung ^" Es soll in $ausfuehrung sein und eine preisliche Obergrenze hast du nicht angegeben.")}
      ^reuse( SUMMARY )
\end{lstlisting}
        
In diesem Pattern, dem 1. Muster aus der Regel, wird anfangs vorgegeben, dass eine positive Zahl nicht am Anfang stehen darf. Es können beliebig viele Token kommen, bis das erste Token aus dem Konzept \texttildelow thingsandart erwähnt wird, optionaler Weise gefolgt von einem 'in' und einem Begriff aus dem Konzept \texttildelow ausfuehrung. Darauf dürfen dann beliebig viele weitere Token folgen. Es ist freigestellt, ob danach noch eine positive Zahl für den Preis angegeben wird.\\
Dabei stehen \lstinline|_0|, \lstinline|_1|, \lstinline|_2| und so weiter für das erste, zweite oder dritte erkannte Wort aus den Konzepten. Im Folgenden wird in einer if-Abfrage ermittelt, ob es sich bei dem ersten Wort um ein Token aus dem Konzept \texttildelow things oder \texttildelow art handelt und entsprechend eine Rückmeldung gegeben.\\ 
Insgesamt 9 verschiedene Muster dieser Art kommen in keyonesentence vor, aufgrund der Tatsache, dass der Nutzer frei angeben kann, ob und wie er Angaben zu Name des Gegenstands, Art, Ausführung oder dem Preis macht.\\


\section{Zufällige Ausgabe}
\label{sec:ChatScript: Zufällige Ausgabe}

ChatScript erlaubt es, dass an einer Stelle mehrere ungesteuerte Ausgaben durch den Bot möglich sind. Mögliche Ausgaben werden mit Hilfe von [] unterschieden:

\begin{lstlisting}{}					%[caption={Regel in keyexonesentence.top}]
u: INTRO ($enter211) [Das ist gut] [Das ist toll] [Das freut mich], [dabei kann ich dir helfen] [ich kann dir dabei helfen, etwas zu finden] [ich kann dich beraten]. Also dann, wollen wir loslegen?
\end{lstlisting}

Hier wählt der Bot zufällig aus, ob "`Das ist gut"', "`Das ist toll"' oder Anderes ausgegeben wird, gefolgt von "`Also dann, wollen wir loslegen?"'.